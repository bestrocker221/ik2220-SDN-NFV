//define ($sw_ip 100.0.0.45,
//		$s1 100.0.0.40,
//		$s2 100.0.0.41,
//		$s3 100.0.0.42,
//		$proto tcp,
//		$port 80
//		)


// how to get interface names ?? TODO
counter_in, counter_drop, counter_out :: AverageCounter;


// setup ifaces
from_ext  :: FromDevice(sw1-eth1, METHOD LINUX, SNIFFER false);
from_int  :: FromDevice(sw1-eth2, METHOD LINUX, SNIFFER false);
to_ext	:: ToDevice(sw1-eth1, METHOD LINUX);
to_int  :: ToDevice(sw1-eth2, METHOD LINUX);

// QUEUES for outgoing traffic
to_int_queue :: Queue(1024) -> to_int;
to_ext_queue :: Queue(1024) -> to_ext;


//
// managing network arping
//
// 12/0806 20/0001 ARP request
// 12/0806 20/0002 ARP response
// 12/0800 IP traffic

// ARPR, ARR , IP Classifiers
from_int -> in_cl :: Classifier(12/0806 20/0001, 12/0806 20/0002, 12/0800, -);
from_ext -> ext_cl :: Classifier(12/0806 20/0001, 12/0806 20/0002, 12/0800, -);


// respond to ARP queries  for the router external interface

ext_cl[0] -> ARPResponder($sw_ip sw1-eth1) -> to_ext_queue ;
ext_cl[1] -> [1]arp :: ARPQuerier($sw_ip, sw1-eth1);

// respond to ARP queries for the router internal interface
in_cl[0] -> ARPResponder($sw_ip sw1-eth2) -> to_int_queue ;
in_cl[1] -> [1]in_arp :: ARPQuerier($sw_ip, sw1-eth2);


to_ext_arp_queue :: GetIPAddress(16) -> CheckIPHeader -> [0]arp -> to_ext_queue;
to_in_arp_queue :: GetIPAddress(16) -> CheckIPHeader -> [0]in_arp -> to_int_queue;

// Classifying IP traffic
ext_cl[2] -> Strip(14) -> CheckIPHeader
	-> ext_ipc :: IPClassifier(
	// ping from out to gw
		icmp && icmp type echo and dst $sw_ip,
	// ping from out to in (generate error)
		icmp && icmp type echo and (dst $s1 or dst $s2 or dst $s3),
	//  tcp traffic  from ext to lb
		dst $sw_ip and $proto port $port,
	// ping resp to rewrited ping
		proto icmp && icmp type echo-reply
	);

in_cl[2] -> Strip(14) -> CheckIPHeader
	-> int_ipc :: IPClassifier(
	// ping from in to in
		icmp && icmp type echo and dst $sw_ip, 
	// tcp from int to ext
		$proto,
	// pings req to rewrite
		icmp && icmp type echo and dst != $sw_ip
		);

// PING BACK
// send back pings gw to outside
ext_ipc[0] -> Print("ICMP ECHO FROM EXT->GW")
    -> ICMPPingResponder
    -> to_ext_arp_queue ;

// send back pings error gw to outside
ext_ipc[1] -> Print("ICMP ECHO FROM EXT-> IN")
    -> ICMPError($sw_ip, 3, 1 ) //host - unreachable
    -> to_ext_arp_queue ;

// send back pings to inside from inside
int_ipc[0] -> Print("ICMP ECHO FROM INT -> INT")
	-> ICMPPingResponder
	-> to_in_arp_queue;

//Discard non-IP, non-ARP packets 
ext_cl[3] -> Print("DISCARDING PACKET") -> Discard
in_cl[3] -> Print("DISCARDING PACKET") -> Discard



// NAT 
// int_ipc[1] = internal IP traffic to outside
// int_ipc[2] = internal ICMP traffic to outside

// ext_ipc[2] = external IP traffic to inside 
// ext_ipc[3] = external ICMP traffic to inside 


ping_rw :: ICMPPingRewriter(pattern $sw_ip 1025-65535# - - 0 1)

ping_rw[1] 	-> to_in_arp_queue
ping_rw[0] ->  to_ext_arp_queue

rr :: RoundRobinIPMapper( $sw_ip - $s1 - 0 1,
						  $sw_ip - $s2 - 0 1,
						  $sw_ip - $s3 - 0 1
						)

rw :: IPRewriter(rr);


rw[0] -> SetTCPChecksum -> to_in_arp_queue;
rw[1] -> SetTCPChecksum -> to_ext_arp_queue;

// FROM EXTERNAL

ext_ipc[2] -> Print("IP from EXT to INT") -> [0]rw;
ext_ipc[3] -> Print("ICMP from EXT to INT") -> [0]ping_rw;

// FROM INTERNAL

int_ipc[1] -> Print("IP from INT to EXT") -> [0]rw;
int_ipc[2] -> Print("ICMP from INT to EXT") -> [0]ping_rw;


// report
DriverManager(wait , print > ids.report  "
	=================== IDS Report ===================
	Input Packet Rate (pps): $(counter_in.rate)
	Output Packet Rate(pps): $(counter_out.rate)
	Total # of input packets: $(counter_in.count)
	Total # of output packets: $(counter_out.count)
	Total # of dropped packets: $(counter_drop.count)
	==================================================
" , stop);
